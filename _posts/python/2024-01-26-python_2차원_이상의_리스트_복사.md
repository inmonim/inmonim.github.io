---
layout: post
title: "[python] 2차원 이상의 리스트 복사"
date: 2024-01-26 16:15:18 +0900
categories: python python이론
tag: [python, 파이썬, 자료구조]
---

# List는 다양한 방법으로 복사가 가능하다.

다만, 필요 시에 따라 복사 방법을 적절히 택해야 하는데,

**복사한 객체가 내부적으로 같은 메모리를 참조**할 수 있기 때문이다.

<br>

## 같은 메모리를 공유하게 만드는 복사

미리 일러두지만,

2차원 배열부터는 `copy 모듈의 deepcopy`를 사용하지 않는 이상,

하나의 명령어로 똑같은 값을 가진 독립된 객체를 생성하기 힘들 수 있다.

2차원 이상의 배열에 대한 정보는 이 포스트에서 확인할 수 있다.

<br>

### List 객체에 곱연산

대표적으로 BFS, DFS 알고리즘 문제를 풀기 위해 2차원 배열을 만들 때다.

visited를 만들기 위해, 길이 3인 정사각형 형태에 0으로 가득찬 배열을 만든다고 하자.

```python
N = 3

arr = [[0] * N for _ in range(N)]

or

arr = [[0] * N] * N
```

두 개의 방법 중, 위의 것이 우리의 의도대로 동작하는 List다.

아래의 방법은, [0] * N 까지는 정상적으로 작동하나, 이 List를 다시 *N 하게 될 경우,

**객체 자체를 새로 만드는 것(새로운 메모리에 할당)** 하는 것이 아닌,

**똑같은 객체를 복사하여 쌓는 것(오리지널 객체의 메모리를 똑같이 참조)**하게 된다.

즉, 만약 arr[0][0]의 값을 5로 바꾸면, arr[1]부터 arr[10]의 첫 번째 객체가 모두 5로 바뀌는 것이다.

```py
n = 3
arr = [[0] * n for _ in range(n)]
arr[0][0] = 5
print(arr)

# [[5, 0, 0], [0, 0, 0], [0, 0, 0]]

wrong_arr = [[0]*n] *n
wrong_arr[0][0] = 5
print(wrong_arr)

# [[5, 0, 0], [5, 0, 0], [5, 0, 0]]
```

더욱 정확하게 파악하기 위해 각 객체의 아이디를 확인해보자.

```python
print(id(arr[0][0]), id(arr[2][0]))

# 140718174626728, 140718174626568

print(id(wrong_arr[0][0]), id(wrong_arr[2][0]))

# 140718174626728 140718174626728

print(id(arr[0][0]) == id(arr[2][0]))

# False

print(id(wrong_arr[0][0]) == id(wrong_arr[2][0]))

# True
```


```python

int

def abc(a :int) -> int:
    for i in range(a):
        print(a)

# fdsafaafsdfads
```

보시다시피, wrong_arr 리스트 내부의 리스트 객체들이 완전히 동일한 객체인 것을 확인할 수 있다.

>여담으로, id(x) == id(y) 와 동일한 기능을 수행하는 연산이 바로 x is y다! <br> 객체의 값이 아닌 객체의 ID를 비교하는 것이 is 연산자다. ==과 헷갈리지 말자.
{: .prompt-tip}

<br>

### list.copy() 메서드

긴말할 필요 없이 말 그대로 **`내부 요소가 똑같은 객체를 하나 더 생성한 것`**이다.

이를 `얕은 복사(shallow copy)`라고 한다.

여기서 주의해야할 것은 `기존의 내부 요소`가 똑같은 것이지 변수에 복사(할당)한 객체 자체가 동일한 것은 아니다.

내부 값의 변화는 공유하므로, 기존에 존재하던 요소의 변경과 삭제는 공유된다.

하지만 내부 요소를 추가하는 경우에는 해당 list의 오리지널 객체가 된다!

코드로 한 번 보자.

```python
arr = [[0] * 3 for _ in range(3)]

copy_arr = arr.copy()

arr[0][1] = 5 # arr에서 바꾸었지만, copy_arr에도 똑같이 적용된다.

print(arr is copy_arr)

# False

print(arr[0][1] is copy_arr[0][1])

# True

copy_arr[0].remove(5)

print(arr[0])

# [0, 0] / copy_arr에서 삭제했지만, 같은 객체이므로 arr도 똑같이 삭제된다.
```

이처럼, copy 메서드는 `내부 요소`가 완전히 동일한 객체를 새로 생성해준다.

<br>

### 직접 할당

입문자나, 뇌 빼고 문제 풀 때 가장 많이 저지르는 실수다.

```python
arr = [[0] * 3 for _ in range(3)]

assign_arr = arr
```

이런 식으로 직접 할당을 해줄 경우, .copy() 메서드보다 더욱 강하게 묶인 객체가 생성된다.

.copy()는 내부 요소들만 똑같게 만들었다면,

직접 할당은 `그냥 완전히 똑같은 객체를 새로 만든 것`이다.

```python
print(arr is assign_arr)

# True  / 변수명만 다른 완전히 똑같은 객체인 것이다

arr.append('이것도 복사해보시지')

print(assign_arr[-1])

# 이것도 복사해보시지
```

내부 요소의 변화는 물론 새롭게 삽입된 객체마저 공유한다!

## 서로 독립된 객체로 복사하는 방법

2차원 이상의 배열에서도 모든 값이 똑같은 독립된 객체를 만드는 것이다.

### copy 모듈의 deepcopy 사용

얕은 복사와 대척되는 깊은 복사다.

아마 가장 간편하지 않을까 싶다.

```python
from copy import deepcopy

arr = [[0] * 3 for _ in range(3)]

deepcopy_arr = deepcopy(arr)

deepcopy_arr[0][1] = 5

print(arr[0][1])

# 0  // 모든 내부 요소들도 서로 독립된 메모리를 참조한다.
```

이는 내부 요소들의 값만 취하여 새로운 메모리에 할당하여 완전히 새로운 객체를 만들어낸다.

## 1차원 배열이라면 이야기가 달라진다.

### 직접 할당을 제외한 대부분의 방법에서 새로운 리스트가 생성된다.

deepcopy를 제외한 다른 방법들은 모두 해당 배열 내부의 객체들을 복사하여 새로운 객체에 집어넣는다.

만약 복사한 객체가 복합자료형이 아닐 경우, 해당 값이 변경되어도 다른 리스트는 따라가지 않는다.

그러나 복합자료형일 경우(depth가 2 이상인 경우), 해당 복합 자료형 객체 자체를 바꿔야 공유된 메모리가 해제된다.

복합 자료형 내부의 값을 바꾸면 해당 리스트와 요소는 같은 메모리를 참조하므로 다른 리스트와 함께 바뀌는 것이다.

