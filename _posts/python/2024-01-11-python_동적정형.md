---
layout: post
title: "[python] 동적 타이핑(동적정형)이란?"
date: 2024-01-11 18:24:18 +0900
categories: python python이론
tag: [python, 파이썬]
---

# 동적 타이핑(동적정형, Dynamic Typing)이란?

>컴파일 단계가 아닌, 실행시간(런타임)에 자료형 검사가 이루어지는 것을 뜻합니다.
{: .prompt-info}

```python

def type_example():
    number = 42
    print(number)
    number = "42"
    print(number)

type_example()

>>> 42
>>> 42
```

Python에서는 위와 같이 `int` 형태로 `number`라는 변수를 생성한 뒤,

`string` 형태로 바꾸어도(재할당) 해도 아무런 문제가 없습니다

다만 이러한 방식은 정적 타이핑 언어에서는 문제가 많이 발생합니다.

## 동적 정형과 정적 정형

```java
public class TypeConversionExample {

    public static void main(String[] args) {
        // 정수형으로 선언된 변수
        int number = 42;

        // 같은 변수명을 가진 다른 타입의 객체 생성 시도
        String number = "42";
    }
}

// 에러 발생
>>> Variable 'number' is already defined in the scope
```

동적 정형의 대척점에 있는 것은 정적 정형으로, 자료형 검사가 컴파일 단계에서 실행되는 것을 말합니다.

컴파일 단계에서는 작성된 소스 코드가 바이너리 코드로 변환되는데,

이 과정에서 변수에 대한 모든 정보가 변환되고, 사용할 메모리 영역이 지정됩니다.

즉, 이 단계에서 사용할 메모리까지 지정이 되므로 런타임 환경에서 변수의 타입이 변환되지 않는 것입니다.

### 그럼 왜 정적 정형을 쓰는가?

정적 정형의 장점은 다음과 같습니다.

1. **에러 방지와 안정성**

  변수가 생성되는 순간부터 자료형이 정해집니다.

  특별한 이유와 수단을 동원하지 않는 이상 쭉 유지되는 것이죠.

  이는 코드를 작성하는 개발자의 입장에서도 타입에 대해 더욱 유의하게끔 만들 수밖에 없습니다.

  따라서 동적 타이핑 언어에서는 자주 벌어지는 타입 변환 오류가 거의 발생하지 않게 됩니다.

2. **속도 및 메모리 최적화**

  컴파일 타임에서 자료형 검사가 끝나기 때문에 런타임에서 굳이 자료형을 검사하지 않습니다.

  컴파일러가 이미 해당 변수의 자료형을 알고 있기 때문에, 최적화된 기계어 코드를 실행할 수 있습니다.

  또한, 메모리 할당과 해제가 더욱 철저하게 이루어지기 때문에 메모리 사용에서도 효율적이라 할 수 있습니다.

3. **IDE의 지원**

  동적 타이핑에서는 IDE에서 변수의 타입을 일일이 추적하여 에러를 표시해주기 상당히 힘듭니다.

  python의 경우 mypy를 활용하면 되지만, 이를 위한 많은 모듈과 라이브러리를 요하게 됩니다.

  정적 타이핑은 IDE 입장에서도 타입 에러를 표시해주기 쉬워집니다.

  소소하지만 코드를 작성하는 때에 큰 도움이 되는 부분이라 생각합니다.

### 그럼 동적 정형은 느리기만 한가?

Python으로 프로그래밍을 시작하고, 또 깊게 파고 있는 입장이라 정적 정형이 가끔은 불편할 때가 있습니다.

저처럼 Python이 **프로그래밍 모국어**인 경우에는 다들 그렇게 느끼실 것 같습니다.

1. **유연성**

  아마 이 단 하나의 이유가 동적 정형을 쓰는 가장 큰 이유가 아닐까 싶습니다.

  얼마든지 새로운 값과 타입을 지정해줄 수 있다는 점은 코딩에 큰 유연성과 편의성을 제공합니다.

2. **코드의 간결성과 생산성 확대**

  변수의 선언문이 매우 간결해집니다.

  java나 Kotlin을 사용하다가 python으로 돌아오면 빠른 걸 넘어서 허전할 정도입니다.

이렇듯, 동적 정형은 코드 작성의 편의성 증대라는 장점이 있습니다.

물론 **런타임에서 타입 검사가 이루어지기 때문에 상당한 오버헤드가 발생한다는 치명적인 단점**이 너무나 큽니다..!


